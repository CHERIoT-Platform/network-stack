// Copyright SCI Semiconductor and CHERIoT Contributors.
// SPDX-License-Identifier: MIT

#include <NetAPI.h>
#include <cstdlib>
#include <debug.hh>
#include <errno.h>
#include <locks.hh>
#include <mqtt.h>
#include <platform-entropy.hh>
#include <platform-gpio.hh>
#include <sntp.h>
#include <string_view>
#include <tick_macros.h>
#include <microvium/microvium.h>

#include "letsencrypt.h"

using CHERI::Capability;

using Debug            = ConditionalDebug<true, "Macrobenchmark">;
using CPUUsage         = ConditionalDebug<true, "CPU Usage">;

// JavaScript support.
namespace
{
	/**
	 * JavaScript bytecode.  The initialiser is generated by running
	 *
	 * ```
	 * microvium --output-bytes app.js > bytecode.inc
	 * ```
	 */
	uint8_t bytecode[] =
#include "bytecode.inc"
	  ;

	/**
	 * Constants for functions exposed to JavaScript->C++ FFI
	 *
	 * The values here must match the ones used in cheri.js.
	 */
	enum Exports : mvm_HostFunctionID
	{
		LEDOn = 1,
		LEDOff,
	};

	/// Constant for the run function exposed to C++->JavaScript FFI
	static constexpr mvm_VMExportID ExportCallback      = 1234;

	/**
	 * Turn an LED on.
	 */
	mvm_TeError export_led_on(mvm_VM            *vm,
	                  mvm_HostFunctionID funcID,
	                  mvm_Value         *result,
	                  mvm_Value         *args,
	                  uint8_t            argCount)
	{
		MMIO_CAPABILITY(GPIO, gpio_led0)->led_on(0);
		return MVM_E_SUCCESS;
	}

	/**
	 * Turn an LED off.
	 */
	mvm_TeError export_led_off(mvm_VM            *vm,
	                  mvm_HostFunctionID funcID,
	                  mvm_Value         *result,
	                  mvm_Value         *args,
	                  uint8_t            argCount)
	{
		MMIO_CAPABILITY(GPIO, gpio_led0)->led_off(0);
	}

	/**
	 * Callback from microvium that resolves imports.  This just resolves the
	 * `print` function as the import corresponding to the `ImportPrint` ID.
	 */
	mvm_TeError resolve_import(mvm_HostFunctionID  funcID,
	                           void               *context,
	                           mvm_TfHostFunction *out)
	{
		if (funcID == LEDOn)
		{
			*out = export_led_on;
			return MVM_E_SUCCESS;
		}
		if (funcID == LEDOff)
		{
			*out = export_led_off;
			return MVM_E_SUCCESS;
		}
		return MVM_E_UNRESOLVED_IMPORT;
	}

	/**
	 * Helper that deletes a Microvium VM when used with a C++ unique pointer.
	 */
	struct MVMDeleter
	{
		void operator()(mvm_VM *mvm) const
		{
			mvm_free(mvm);
		}
	};

	std::unique_ptr<mvm_VM, MVMDeleter> vm;
} // namespace

// Don't use IPv6 in the macro-benchmark.
constexpr bool UseIPv6 = false;

// MQTT network buffer sizes.
constexpr const size_t networkBufferSize    = 2048;
constexpr const size_t incomingPublishCount = 100;
constexpr const size_t outgoingPublishCount = 100;

namespace
{
	DECLARE_AND_DEFINE_CONNECTION_CAPABILITY(DemoHost,
	                                         "demo.cheriot.org",
	                                         8883,
	                                         ConnectionTypeTCP);

	DECLARE_AND_DEFINE_ALLOCATOR_CAPABILITY(mqttTestMalloc, 32 * 1024);

	constexpr std::string_view LedTopic{"macrobenchmark-led"};
	int32_t                    ledSubscribePacketId = -1;
	bool                       ledAckReceived       = false;

	/**
	 * Note from the MQTT 3.1.1 spec:
	 * The Server MUST allow ClientIds which are between 1 and 23 UTF-8 encoded
	 * bytes in length, and that contain only the characters
	 * "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	 *
	 * Note from us:
	 * UTF-8 encoding of 0-9, a-z, A-Z, is 1 Byte per character, so we should be
	 * able to do up to a length of 22 characters + zero byte.
	 */
	constexpr const int clientIDlength           = 23;
	constexpr const int clientIDPrefixLength     = 8;
	char                clientID[clientIDlength] = "cheriot-XXXXXXXXXXXXXX";

	static uint32_t printCyclesGuard;

	/// Callbacks
	void __cheri_callback ackCallback(uint16_t packetID, bool isReject)
	{
		if (packetID == ledSubscribePacketId)
		{
			ledAckReceived = true;
		}
	}

	void __cheri_callback publishCallback(const char *topicName,
	                                      size_t      topicNameLength,
	                                      const void *payload,
	                                      size_t      payloadLength)
	{
		std::string_view topic{topicName, topicNameLength};
		if (topic == LedTopic)
		{
			Debug::log("{}: Received an LED publish.", rdcycle64());

			// Get a handle to the JavaScript `callback` function.
			mvm_Value callback;
			mvm_TeError err = mvm_resolveExports(vm.get(), &ExportCallback, &callback, 1);
			Debug::Assert(
			  err == MVM_E_SUCCESS, "Failed to get callback function: {}", err);

			// Call the function:
			err = mvm_call(vm.get(), callback, nullptr, nullptr, 0);
			Debug::Assert(
			  err == MVM_E_SUCCESS, "Failed to call callback function: {}", err);

			printCyclesGuard = 0;
		}
	}

	/// Handle to the MQTT connection.
	MQTTConnection handle;
} // namespace

void __cheri_compartment("macrobenchmark") cpu_clock()
{
	uint64_t lastCycles     = 0;
	uint64_t lastIdleCycles = 0;

	while (printCyclesGuard == 0)
	{
		futex_wait(&printCyclesGuard, 0);
	}

	while (printCyclesGuard != 2)
	{
		if (printCyclesGuard == 0)
		{
			// One last round.
			printCyclesGuard = 2;
		}

		uint64_t idleCycles         = thread_elapsed_cycles_idle();
		uint64_t cycles             = rdcycle64();
		uint32_t elapsedCycles      = cycles - lastCycles;
		uint32_t idleElsapsedCycles = idleCycles - lastIdleCycles;

		lastCycles                  = cycles;
		lastIdleCycles              = idleCycles;

		CPUUsage::log("{}: {} %", cycles, (int) ((100 * (elapsedCycles - idleElsapsedCycles)) / elapsedCycles));
		Timeout t{MS_TO_TICKS(1000)};
		thread_sleep(&t);
	}
}

void __cheri_compartment("macrobenchmark") macrobenchmark()
{
	int     ret;
	Timeout t{MS_TO_TICKS(5000)};

	MMIO_CAPABILITY(GPIO, gpio_led0)->enable_all();

	Debug::log("{}: Starting the network stack.", rdcycle64());
	printCyclesGuard = 1;
	futex_wake(&printCyclesGuard, 1);
	network_start();

	// SNTP must be run for the TLS stack to be able to check certificate
	// dates.
	Debug::log("{}: Fetching NTP time.", rdcycle64());
	t = Timeout{MS_TO_TICKS(5000)};
	while (sntp_update(&t) != 0)
	{
		//Debug::log("Failed to update NTP time");
		t = Timeout{MS_TO_TICKS(5000)};
	}

	{
		timeval tv;
		int     ret = gettimeofday(&tv, nullptr);
		if (ret != 0)
		{
			Debug::log("Failed to get time of day: {}", ret);
		}
		else
		{
			// Truncate the epoch time to 32 bits for printing.
			Debug::log("Current UNIX epoch time: {}", (int32_t)tv.tv_sec);
		}
	}

	Debug::log("{}: Setting up the JS VM.", rdcycle64());
	{
		mvm_VM *rawVm;
		mvm_TeError                         err = mvm_restore(&rawVm,
		                  bytecode,
		                  sizeof(bytecode),
		                  MALLOC_CAPABILITY,
		                  ::resolve_import);
		Debug::Assert(
		  err == MVM_E_SUCCESS, "Failed to parse bytecode: {}", err);
		vm.reset(rawVm);
	}

	// Macrobenchmark loop.
	while (true)
	{
		Debug::log("{}: Connecting to MQTT broker...", rdcycle64());
		// Generate a client ID.
		mqtt_generate_client_id(clientID + clientIDPrefixLength,
		                        clientIDlength - clientIDPrefixLength - 1);

		handle = mqtt_connect(&t,
		                      STATIC_SEALED_VALUE(mqttTestMalloc),
		                      STATIC_SEALED_VALUE(DemoHost),
		                      publishCallback,
		                      ackCallback,
		                      TAs,
		                      TAs_NUM,
		                      networkBufferSize,
		                      incomingPublishCount,
		                      outgoingPublishCount,
		                      clientID,
		                      strlen(clientID));

		if (!Capability{handle}.is_valid())
		{
			Debug::log("Failed to connect, retrying...");
			Timeout pause{MS_TO_TICKS(1000)};
			thread_sleep(&pause);
			continue;
		}

		Debug::log("{}: Subscribing to the topic.", rdcycle64());
		ret = mqtt_subscribe(&t,
		                     handle,
		                     1, // QoS 1 = delivered at least once
		                     LedTopic.data(),
		                     LedTopic.size());

		if (ret < 0)
		{
			Debug::log("Failed to subscribe, error {}.", ret);
			mqtt_disconnect(&t, STATIC_SEALED_VALUE(mqttTestMalloc), handle);
			continue;
		}

		ledSubscribePacketId = ret;

		while (!ledAckReceived)
		{
			t   = Timeout{MS_TO_TICKS(1000)};
			ret = mqtt_run(&t, handle);

			if (ret < 0)
			{
				Debug::log(
				  "Failed to wait for the SUBACK for the code node, error {}.",
				  ret);
				mqtt_disconnect(
				  &t, STATIC_SEALED_VALUE(mqttTestMalloc), handle);
				continue;
			}
		}

		Timeout coolDown{0};
		Debug::log("{}: Waiting for a PUBLISH.", rdcycle64());
		while (true)
		{
			// Check for PUBLISHes
			t = Timeout{MS_TO_TICKS(100)};
			// Debug::log("{} bytes of heap free", heap_available());
			ret = mqtt_run(&t, handle);

			if ((ret < 0) && (ret != -ETIMEDOUT))
			{
				Debug::log("Failed to wait for PUBLISHes, error {}.", ret);
				break;
			}
		}

		Debug::log("Exiting main loop, cleaning up.");
		mqtt_disconnect(&t, STATIC_SEALED_VALUE(mqttTestMalloc), handle);
		// Sleep for a second to allow the network stack to clean up any
		// outstanding allocations
		Timeout oneSecond{MS_TO_TICKS(1000)};
		thread_sleep(&oneSecond);
	}
}
